# Introduction / Getting Started
## Important notes
** *
### Compilers, Interpreters and Assembly
** *
* We can write the same command in 3 different ways of abstraction:
    * **Machine Language**: `10110000 01100001`
    * **Assembly**: `mov al, 061h`
    * **C/C++**: `a=97;`
    
* Of course, we need a software that translate our source code to a machine language that our CPU understand.
* **Assembler** translates **assembly code** to the appropriate **machine languge**.
* **Compiler** produces an **exectuable** from **high-level** language source code. Than, its output can be run on the **hardware**.
* **Interpreter** can **directly executes** the instruction in the **source code** without requiring them to be compiled into an exectuble first.
* Comparison of Compiler vs. Interpreter:
 
 | Key | Compiler | Intrepreter |
| :----: | :---: | :-------: |
| Static Optimization | High, because they can see all the code up-front, they can perform a number of analyses and optimizations when generating code that makes the final version of the code executed faster. | Low, actually doesn't has the ability to optimize the code as the compiler has. |
| Dynamic Optimization | Depends, for example dynamic typing, dynamic bind and more, are difficult to compile efficiently because the compiler can't predict what's going to happen until the program is actually run. | High, interpreters can use a number of dynamic optimizations that compilers might not be able to see (for the same reason) |
| Run time performance | High, the instructions executed are usually just for the program itself. | Low, spend some CPU time inside of the code for the interpreter, which can slow down the program being run.
| Start up time | High, because of optimizations, analysis and generate the whole executable | Low, it run what it's see immediately |
| Memory usage | Low, can organize better the data and the information that should be stored during runtime. | High, needs to keep more information about the program available at runtime. |

* Most languages can be compiled or interpreted, however, traditionally languages like **C, C++**, and Pascal are **compiled**, whereas **“scripting”** languages like Perl and Javascript tend to be **interpreted**. Some languages, like Java, use a **mix of the two**.

* **A little story about Java**: because interpreters and compilers have complementary strengths and weaknesses, it's becoming increasingly common for language runtimes to combine elements of both. Java's JVM is a good example of this - the Java code itself is compiled, and initially it's interpreted. The JVM can then find code that's run many, many times and compile it directly to machine code, meaning that "hot" code gets the benefits of compilation while "cold" code does not. The JVM can also perform a number of dynamic optimizations like inline caching to speed up performance in ways that compilers typically don't.

### C/C++ Background
** *
* The underlying design philosophy of C and C++ can be summed up as **“trust the programmer”** -- which is both wonderful and dangerous. 
* C++ excels in situations where **high performance** and precise control over memory and other resources is needed
* Source files are written with extension of *.cpp.
* A **Compiler** compiles *.cpp file into a *.o
* After the compiler creates one or more object files, then another program called the **linker** kicks in, its output is an ***executable*** file. The job of the linker is three fold:
    * First, to take all the object files generated by the compiler and combine them into a single executable program.
    * Second, in addition to being able to link object files, the linker also is capable of *linking library files*. A **library file** is a collection of precompiled code that has been “packaged up” for reuse in other programs.
    * Third, the linker makes sure all cross-file dependencies are resolved properly. For example, if you define something in one .cpp file, and then use it in another .cpp file, the linker connects the two together. If the linker is unable to connect a reference to something with its definition, you’ll get a linker error, and the linking process will abort.
* What is the difference between the compile, build, rebuild, clean, and run/start options in my IDE?
    * **Build** compiles all modified code files in the project or workspace/solution, and then links the object files into an executable. If no code files have been modified since the last build, this option does nothing.
    * **Clean** removes all cached objects and executables so the next time the project is built, all files will be recompiled and a new executable produced.
    * **Rebuild** does a “clean”, followed by a “build”.
    * **Compile** recompiles a single code file (regardless of whether it has been cached previously). This option does not invoke the linker or produce an executable.
    * **Run/start** executes the executable from a prior build. Some IDEs (e.g. Visual Studio) will invoke a “build” before doing a “run” to ensure you are running the latest version of your code. Otherwise (e.g. Code::Blocks) will just execute the prior executable.
* **Compiler Extenstions:** The C++ standard defines rules about how programs should behave in specific circumstances. And in most cases, compilers will follow these rules. However, many compilers implement their own changes to the language, often to enhance compatibility with other versions of the language (e.g. C99), or for historical reasons. These compiler-specific behaviors are called compiler extensions. Writing a program that makes use of a compiler extension allows you to write programs that are incompatible with the C++ standard. Programs using non-standard extensions generally will not compile on other compilers (that don’t support those same extensions), or if they do, they may not run correctly.